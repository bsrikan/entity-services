xquery version "1.0-ml";

(: This module was generated by MarkLogic Entity Services. 
 : The source entity type document was Race-0.0.1
 :
 : Modification History:
 :   Generated at timestamp: 2016-04-01T16:20:21.117896-07:00
 :   Modified to lookup/denormalize runner into run, and source from JSON raw,
 :   Persisted by Charles Greer
 :   Date: 2016-04-01
 :)
module namespace race = "http://grechaw.github.io/entity-types#Race-0.0.1";

import module namespace functx   = "http://www.functx.com" at "/MarkLogic/functx/functx-1.0-nodoc-2007-01.xqy";
import module namespace es = "http://marklogic.com/entity-services" 
    at "/MarkLogic/entity-services/entity-services.xqy";

(:~
 : Generates an insance of "Race" type 
 : From JSON sources
 :)
declare function race:extract-instance-Race(
    $source-node as node()
) as map:map
{
    let $instance := json:object()
    let $_ := map:put($instance, "$type", "Race")
    let $_ := map:put($instance, "$attachments", xdmp:quote($source-node))
    let $_ := map:put($instance, 'name', $source-node/name ! data(.))
    let $_ := map:put($instance, "comprisedOfRuns", json:to-array($source-node/comprisedOfRuns))
    let $_ := if (empty( ($source-node/wonByRunner)))
         then () 
         else map:put($instance, 'wonByRunner', data($source-node/wonByRunner))
    let $_ := map:put($instance, 'courseLength', data($source-node/courseLength))
    return $instance
};
    
declare function race:extract-instance-Run(
    $source-node as node()
) as map:map
{
    let $instance := json:object()
    let $_ := map:put($instance, "$type", "Run")
    let $_ := map:put($instance, "$attachments", xdmp:quote($source-node))
    let $_ := map:put($instance, 'id', $source-node/id ! data(.))
    let $_ := map:put($instance, 'date', $source-node/date ! data(.))
    let $_ := map:put($instance, 'distance', $source-node/distance ! data(.))
    let $_ := map:put($instance, 'distanceLabel', $source-node/distanceLabel ! data(.))
    let $_ := map:put($instance, 'duration', $source-node/duration ! functx:dayTimeDuration((), (), xs:decimal(.), ()))
    let $runner-name := string($source-node/runByRunner)
    let $runnerDoc := cts:search( collection("raw"), cts:json-property-value-query("name", $runner-name))
    let $_ := map:put($instance, "runByRunner", race:extract-instance-Runner($runnerDoc))
    return $instance
};
    

(: modifying this one for JSON inputs, each a separate file :)
declare function race:extract-instance-Runner(
    $source-node as node()
) as map:map
{
    let $instance := json:object()
    let $_ := map:put($instance, "$type", "Runner")
    let $_ := map:put($instance, 'name', $source-node/name ! data(.))
    let $_ := map:put($instance, 'age', $source-node/age ! data(.))
    let $_ := map:put($instance, 'gender', $source-node/gender ! data(.))
    return $instance
};
    

(: instance-to-canonical-xml function
 : Depending on the relationships among your entity types
 : you may wish to modify sections of this function
 : to meet your own purposes.
 :)
declare function race:instance-to-canonical-xml(
    $entity-instance as map:map
) as element(es:instance)
{
    let $title := "Race"
    let $version := "0.0.1"
    let $instance-keys := map:keys($entity-instance)
    let $instance-node :=
        (: Construct the instance wrapper element itself :)
        element es:instance {
            (: Construct the metadata for the instance :)
            element es:info {
                element es:title { $title },
                element es:version { $version }
                (: TODO id :)
            },
            (: Construct an element that is named the same as the Entity Type :)
            element { map:get($entity-instance, "$type") }  {
                for $key in $instance-keys
                let $instance-property := map:get($entity-instance, $key)
                where ($key castable as xs:NCName and $key ne "$type")
                return
                    typeswitch ($instance-property)
                    (: This branch handles embedded objects.  You can choose to prune
                       an entity's representation of extend it with lookups here. :)
                    case json:object+ 
                        return
                            for $prop in $instance-property
                            return element { $key } { race:instance-to-canonical-xml($prop)/(*[exists(./*)] except es:info) }
                    (: An array by convention can also treated as multiple elements :)
                    case json:array
                        return 
                            for $val in json:array-values($instance-property)
                            return element { $key } { $val }
                    (: A sequence of values should be simply treated as multiple elements :)
                    case item()+
                        return 
                            for $val in $instance-property
                            return element { $key } { $val }
                    default return element { $key } { $instance-property }
            }
        }
    return $instance-node
};


(: instance-to-envelope 
 : This function is used to wrap sources and entity instances
 : within the same document
 :)
declare function race:instance-to-envelope(
    $entity-instance as map:map
) as element(es:envelope)
{
    element es:envelope {
        race:instance-to-canonical-xml($entity-instance),
        element es:attachments {
            map:get($entity-instance, "$attachments") 
        }
    }
};


(: instance-from-document 
 : if you have modified instance-to-envelope
 : you may need also to modify this function
 :)
declare function race:instance-from-document(
    $document as document-node()
) as map:map*
{
    let $xml-from-document := race:instance-xml-from-document($document)
    for $root-instance in $xml-from-document
        let $instance := json:object()
        let $_ :=
            for $property in $root-instance/*
            return
                if ($property/element())
                then map:put($instance, local-name($property), $property/* ! race:child-instance(.))
                else map:put($instance, local-name($property), data($property))
        return $instance
};

declare function race:child-instance(
    $element as element()
) as map:map*
{
    let $child := json:object()
    let $_ := 
        for $property in $element/*
        return
            if ($property/element())
            then map:put($child, local-name($property), race:child-instance($property))
            else map:put($child, local-name($property), data($property))
    return $child
};


(:~
 : Returns all XML from within a document envelope except the es:info.
 : This function is generic enough not to require customization for
 : most entity type implementations.
 :)
declare function race:instance-xml-from-document(
    $document as document-node()
) as element()
{
    $document//es:instance/(* except es:info)
};

declare function race:instance-json-from-document(
    $document as document-node()
) as object-node()
{
    let $instance := race:instance-from-document($document)
    return xdmp:to-json($instance)/node()
};


declare function race:instance-get-attachments(
    $document as document-node()
) as element()*
{
    $document//es:attachments/*
};

