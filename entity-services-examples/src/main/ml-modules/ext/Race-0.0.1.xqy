xquery version "1.0-ml";

(: This module was generated by MarkLogic Entity Services. 
 : The source entity type document was Race-0.0.1
 :
 : Modification History:
 :   Generated at timestamp: 2016-04-13T13:41:03.235074-07:00
 :   Modified to lookup/denormalize runner into run, and source from JSON raw,
 :   Persisted by Charles Greer
 :   Date: 2016-04-01
 :)
module namespace race = "http://grechaw.github.io/entity-types#Race-0.0.1";

import module namespace functx   = "http://www.functx.com" at "/MarkLogic/functx/functx-1.0-nodoc-2007-01.xqy";
import module namespace es = "http://marklogic.com/entity-services" 
    at "/MarkLogic/entity-services/entity-services.xqy";


declare private function race:include-if-exists(
    $property-path,
    $instance,
    $property-key,
    $value
) as empty-sequence()
{
    if (exists($property-path))
    then 
    map:put($instance, $property-key, $value) 
    else ()
};


(: extract-instance-{entity-type} Functions :)

(:~
 : Generates an insance of "Race" type 
 :)
declare function race:extract-instance-Race(
    $source-node as node()
) as map:map
{
    let $instance := json:object()
    let $_ := map:put($instance, "$type", "Race")
    let $_ := map:put($instance, "$attachments", xdmp:quote($source-node))
    let $_ := race:include-if-exists($source-node/name, $instance, 'name', data($source-node/name))
    (: reference not embedded :)
    let $_ := map:put($instance, "comprisedOfRuns", json:to-array($source-node/comprisedOfRuns))
    let $_ := race:include-if-exists($source-node/wonByRunner, $instance, 'wonByRunner', data($source-node/wonByRunner))
    let $_ := race:include-if-exists($source-node/courseLength, $instance, 'courseLength', data($source-node/courseLength))
   
    return $instance
};
    
(:~
    TODO make descriptive comment for extract-instance-Run
 :)
declare function race:extract-instance-Run(
    $source-node as node()
) as map:map
{
    let $instance := json:object()
    let $_ := map:put($instance, "$type", "Run")
    let $_ := map:put($instance, "$attachments", xdmp:quote($source-node))
    let $_ := race:include-if-exists($source-node/id, $instance, 'id', data($source-node/id))
    let $_ := race:include-if-exists($source-node/date, $instance, 'date', data($source-node/date))
    let $_ := race:include-if-exists($source-node/distance, $instance, 'distance', data($source-node/distance))
    let $_ := race:include-if-exists($source-node/distanceLabel, $instance, 'distanceLabel', data($source-node/distanceLabel))
    let $_ := race:include-if-exists($source-node/duration, $instance, 'duration', functx:dayTimeDuration((), (), xs:decimal($source-node/duration), ()))
    let $runner-name := string($source-node/runByRunner)
    let $runnerDoc := cts:search( collection("raw"), cts:json-property-value-query("name", $runner-name))
    let $_ := map:put($instance, "runByRunner", race:extract-instance-Runner($runnerDoc))
   
    return $instance
};
    
(: modifying this one for JSON inputs, each a separate file :)
declare function race:extract-instance-Runner(
    $source-node as node()
) as map:map
{
    let $instance := json:object()
    let $_ := map:put($instance, "$type", "Runner")
    let $_ := race:include-if-exists($source-node/name, $instance, 'name', data($source-node/name))
    let $_ := race:include-if-exists($source-node/age, $instance, 'age', data($source-node/age))
    let $_ := race:include-if-exists($source-node/gender, $instance, 'gender', data($source-node/gender))
   
    return $instance
};
    

(: instance-to-canonical-xml function
 : Depending on the relationships among your entity types
 : you may wish to modify sections of this function
 : to meet your own purposes.
 :)
declare function race:instance-to-canonical-xml(
    $entity-instance as map:map
) as element()
{
    (: Construct an element that is named the same as the Entity Type :)
    element { map:get($entity-instance, "$type") }  {
        for $key in map:keys($entity-instance)
        let $instance-property := map:get($entity-instance, $key)
        where ($key castable as xs:NCName and $key ne "$type")
        return
            typeswitch ($instance-property)
            (: This branch handles embedded objects.  You can choose to prune
               an entity's representation of extend it with lookups here. :)
            case json:object+ 
                return
                    for $prop in $instance-property
                    return element { $key } { race:instance-to-canonical-xml($prop) }
            (: An array can also treated as multiple elements :)
            case json:array
                return 
                    for $val in json:array-values($instance-property)
                    return
                        if ($val instance of map:map)
                        then element { $key } { race:instance-to-canonical-xml($val) }
                        else element { $key } { $val }
            (: A sequence of values should be simply treated as multiple elements :)
            case item()+
                return 
                    for $val in $instance-property
                    return element { $key } { $val }
            default return element { $key } { $instance-property }
    }
};


(: instance-to-envelope 
 : This function is used to wrap sources and entity instances
 : within the same document
 : TODO EA-3, this will be part of XQuery server library, not generated code.
 :)
declare function race:instance-to-envelope(
    $entity-instance as map:map
) as document-node()
{
    document {
        element es:envelope {
            element es:instance {
                element es:info {
                    element es:title { "Race" },
                    element es:version { "0.0.1" }
                },
                race:instance-to-canonical-xml($entity-instance)
            },
            element es:attachments {
                map:get($entity-instance, "$attachments") 
            }
        }
    }
};


(: instance-from-document 
 : if you have modified instance-to-envelope
 : you may need also to modify this function
 :)
declare function race:instance-from-document(
    $document as document-node()
) as map:map*
{
    let $xml-from-document := race:instance-xml-from-document($document)
    for $root-instance in $xml-from-document
        let $instance := json:object()
        let $_ :=
            for $property in $root-instance/*
            return
                if ($property/element())
                then map:put($instance, local-name($property), $property/* ! race:child-instance(.))
                else map:put($instance, local-name($property), data($property))
        return $instance
};

declare function race:child-instance(
    $element as element()
) as map:map*
{
    let $child := json:object()
    let $_ := 
        for $property in $element/*
        return
            if ($property/element())
            then map:put($child, local-name($property), race:child-instance($property))
            else map:put($child, local-name($property), data($property))
    return $child
};


(:~
 : Returns all XML from within a document envelope except the es:info.
 : This function is generic enough not to require customization for
 : most entity type implementations.
 :)
declare function race:instance-xml-from-document(
    $document as document-node()
) as element()
{
    $document//es:instance/(* except es:info)
};

declare function race:instance-json-from-document(
    $document as document-node()
) as object-node()
{
    let $instance := race:instance-from-document($document)
    return xdmp:to-json($instance)/node()
};


declare function race:instance-get-attachments(
    $document as document-node()
) as element()*
{
    $document//es:attachments/*
};

