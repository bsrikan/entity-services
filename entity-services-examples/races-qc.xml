<export><workspace name="races"><query name="01. generate-artifacts" focus="false" listorder="2" taborder="2" active="true" database="4021040855339281678" server="2128340906940504599" mode="xquery">(: Using database entity-services-examples-content :)
xquery version "1.0-ml";
import module namespace es = "http://marklogic.com/entity-services" at "/MarkLogic/entity-services/entity-services.xqy"; 
import module namespace esi = "http://marklogic.com/entity-services-impl" at "/MarkLogic/entity-services/entity-services-impl.xqy"; 

declare variable $PATH as xs:string := "/Users/jmakeig/Workspaces";

(: this script generates all of the artifacts supported in Entity Services for EA-2 :)
let $project-location := $PATH || "/xdmp-entity-services/entity-services-examples"
let $gen-prefix := $project-location || "/gen/"
let $d := es:entity-type-from-node(fn:doc("simple-race.json"))
return ($d ,
  xdmp:save($gen-prefix || "ml-modules/ext/Race-0.0.1.xqy", es:conversion-module-generate($d)),
  xdmp:save($gen-prefix || "ml-schemas/Race-0.0.1.tdex", es:extraction-template-generate($d)),
  xdmp:save($gen-prefix || "ml-schemas/Race-0.0.1.xsd", es:schema-generate($d)),
  xdmp:save($gen-prefix || "ml-config/databases/content-database.json", es:database-properties-generate($d))
)</query><query name="03. check extract-instance" focus="false" listorder="3" taborder="4" active="true" database="4021040855339281678" server="2128340906940504599" mode="xquery">(: Using database entity-services-examples-content :)
xquery version "1.0-ml";
import module namespace race = "http://grechaw.github.io/entity-types#Race-0.0.1" at "/ext/Race-0.0.1.xqy";

declare variable $PATH as xs:string := "/Users/jmakeig/Workspaces";

(: This script runs extract functions to verify the initial import and how extraction looks :)
let $runner-e := race:extract-instance-Runner(
  doc($PATH || "/xdmp-entity-services/entity-services-examples/data/simple-race-0.0.1/runners/xaw.json")
)
let $run-e := race:extract-instance-Run(
  doc($PATH || "/xdmp-entity-services/entity-services-examples/data/simple-race-0.0.1/runs/138.json")
)
let $race-e := race:extract-instance-Race(
  doc($PATH || "/xdmp-entity-services/entity-services-examples/data/simple-race-0.0.1/races/10k2.json")
)

return (
  $runner-e,
  $run-e,
  race:instance-to-envelope($run-e),
  $race-e,
  race:instance-to-envelope($race-e)
)</query><query name="02. ingest" focus="false" listorder="1" taborder="3" active="true" database="4021040855339281678" server="2128340906940504599" mode="xquery">(: Using database entity-services-examples-content :)
xquery version "1.0-ml";
import module namespace race = "http://grechaw.github.io/entity-types#Race-0.0.1" at "/ext/Race-0.0.1.xqy";

(: This is the ingest script.  In my case, 'staging' is a collection.
 : The ingestion embeds runners into runs, and so we skip runners and
 : just do run ingestion.
 :)
for $uri in cts:uris( (), (), cts:collection-query("raw") )
return 
  if (contains($uri, "/runners/"))
  then () (: "runners" are denormalized into runs, so we don't put them in prod as separate doc. :)
  else if (contains($uri, "/runs/"))
  then
    xdmp:document-insert("/runs/" || xdmp:random() || ".xml", 
      race:instance-to-envelope(
        race:extract-instance-Run(doc($uri))), 
      xdmp:default-permissions(), "run-envelopes")
  else if (contains($uri, "/races/"))
  then
    xdmp:document-insert("/races/" || xdmp:random() || ".xml", 
      race:instance-to-envelope(
        race:extract-instance-Race(doc($uri))), 
      xdmp:default-permissions(), "race-envelopes")
  else ()

</query><query name="05. race" focus="false" listorder="5" taborder="6" active="true" database="4021040855339281678" server="2128340906940504599" mode="sql">-- USE entity-services-examples-content;

SELECT 
  Race.name, 
  Race.wonByRunner, 
  Race.courseLength, 
  Run.id, 
  Run.distance, 
  Run.duration, 
  Run.runByRunner
FROM 
  Race, Run
JOIN Race_comprisedOfRuns AS r ON Race.name = r.name
WHERE
  r.comprisedOfRuns = Run.id
  AND Race.name = 'Half Marathon One'
ORDER BY Run.duration
</query><query name="04. tde-manual" focus="false" listorder="4" taborder="5" active="true" database="4021040855339281678" server="2128340906940504599" mode="xquery">(: Using database entity-services-examples-content :)
xquery version "1.0-ml";
import module namespace es = "http://marklogic.com/entity-services" at "/MarkLogic/entity-services/entity-services.xqy"; 

declare variable $PATH as xs:string := "/Users/jmakeig/Workspaces";

(: this is a manual run of tde functionality to verify generated extraction tempaltes :)
let $tde := xdmp:filesystem-file($PATH || "/xdmp-entity-services/entity-services-examples/src/main/ml-schemas/Race-0.0.1.tdex")
let $doc := (//es:instance/Run/id)/root()
let $ex := tde:document-data-extract($doc, xdmp:unquote($tde)/node())
return $ex </query><query name="06. run" focus="false" listorder="9" taborder="7" active="true" database="4021040855339281678" server="2128340906940504599" mode="sql">-- USE entity-services-examples-content;
SELECT distance, count(*)
FROM Run
GROUP by distance
ORDER by distance DESC</query><query name="SPARQL" focus="false" listorder="11" taborder="8" active="true" database="4021040855339281678" server="2128340906940504599" mode="sparql"># Using database entity-services-examples-content

select distinct ?p ?o
where 
{
  &lt;http://grechaw.github.io/entity-types/Race-0.0.1/Runner&gt; ?p ?o
}</query><query name="00. README" focus="true" listorder="8" taborder="1" active="true" database="4021040855339281678" server="2128340906940504599" mode="xquery">(:
 : 
 :
 :
 :)</query></workspace></export>
