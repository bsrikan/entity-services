xquery version "1.0-ml";

(: This module was generated by MarkLogic Entity Services. 
 : The source entity type document was Race-0.0.1
 :
 : Modification History:
 :   Generated at timestamp: 2016-04-13T13:40:08.259509-07:00
 :   Persisted by AUTHOR
 :   Date: DATE
 :)
module namespace race = "http://grechaw.github.io/entity-types#Race-0.0.1";

import module namespace es = "http://marklogic.com/entity-services" 
    at "/MarkLogic/entity-services/entity-services.xqy";


declare private function race:include-if-exists(
    $property-path,
    $instance,
    $property-key,
    $value
) as empty-sequence()
{
    if (exists($property-path))
    then 
    map:put($instance, $property-key, $value) 
    else ()
};


(: extract-instance-{entity-type} Functions :)

(:~
    TODO make descriptive comment for extract-instance-Race
 :)
declare function race:extract-instance-Race(
    $source-node as node()
) as map:map
{
    let $instance := json:object()
    let $_ := map:put($instance, "$type", "Race")
    let $_ := map:put($instance, "$attachments", $source-node)
    let $_ := race:include-if-exists($source-node/Race/name, $instance, 'name', data($source-node/Race/name))
    let $_ := race:include-if-exists($source-node/Race/comprisedOfRuns, $instance, 'comprisedOfRuns', 
    if ($source-node/Race/comprisedOfRuns/element())
    then json:to-array($source-node/Race/comprisedOfRuns ! race:extract-instance-Run(.))
    else data($source-node/Race/comprisedOfRuns))
    let $_ := race:include-if-exists($source-node/Race/wonByRunner, $instance, 'wonByRunner', 
    if ($source-node/Race/wonByRunner/element())
    then json:to-array($source-node/Race/wonByRunner ! race:extract-instance-Runner(.))
    else data($source-node/Race/wonByRunner))
    let $_ := race:include-if-exists($source-node/Race/courseLength, $instance, 'courseLength', data($source-node/Race/courseLength))
   
    return $instance
};
    
(:~
    TODO make descriptive comment for extract-instance-Run
 :)
declare function race:extract-instance-Run(
    $source-node as node()
) as map:map
{
    let $instance := json:object()
    let $_ := map:put($instance, "$type", "Run")
    let $_ := map:put($instance, "$attachments", $source-node)
    let $_ := race:include-if-exists($source-node/Run/id, $instance, 'id', data($source-node/Run/id))
    let $_ := race:include-if-exists($source-node/Run/date, $instance, 'date', data($source-node/Run/date))
    let $_ := race:include-if-exists($source-node/Run/distance, $instance, 'distance', data($source-node/Run/distance))
    let $_ := race:include-if-exists($source-node/Run/distanceLabel, $instance, 'distanceLabel', data($source-node/Run/distanceLabel))
    let $_ := race:include-if-exists($source-node/Run/duration, $instance, 'duration', data($source-node/Run/duration))
    let $_ := race:include-if-exists($source-node/Run/runByRunner, $instance, 'runByRunner', 
    if ($source-node/Run/runByRunner/element())
    then json:to-array($source-node/Run/runByRunner ! race:extract-instance-Runner(.))
    else data($source-node/Run/runByRunner))
   
    return $instance
};
    
(:~
    TODO make descriptive comment for extract-instance-Runner
 :)
declare function race:extract-instance-Runner(
    $source-node as node()
) as map:map
{
    let $instance := json:object()
    let $_ := map:put($instance, "$type", "Runner")
    let $_ := map:put($instance, "$attachments", $source-node)
    let $_ := race:include-if-exists($source-node/Runner/name, $instance, 'name', data($source-node/Runner/name))
    let $_ := race:include-if-exists($source-node/Runner/age, $instance, 'age', data($source-node/Runner/age))
    let $_ := race:include-if-exists($source-node/Runner/gender, $instance, 'gender', data($source-node/Runner/gender))
   
    return $instance
};
    

(: instance-to-canonical-xml function
 : Depending on the relationships among your entity types
 : you may wish to modify sections of this function
 : to meet your own purposes.
 :)
declare function race:instance-to-canonical-xml(
    $entity-instance as map:map
) as element()
{
    (: Construct an element that is named the same as the Entity Type :)
    element { map:get($entity-instance, "$type") }  {
        for $key in map:keys($entity-instance)
        let $instance-property := map:get($entity-instance, $key)
        where ($key castable as xs:NCName and $key ne "$type")
        return
            typeswitch ($instance-property)
            (: This branch handles embedded objects.  You can choose to prune
               an entity's representation of extend it with lookups here. :)
            case json:object+ 
                return
                    for $prop in $instance-property
                    return element { $key } { race:instance-to-canonical-xml($prop) }
            (: An array can also treated as multiple elements :)
            case json:array
                return 
                    for $val in json:array-values($instance-property)
                    return
                        if ($val instance of json:object)
                        then element { $key } { race:instance-to-canonical-xml($val) }
                        else element { $key } { $val }
            (: A sequence of values should be simply treated as multiple elements :)
            case item()+
                return 
                    for $val in $instance-property
                    return element { $key } { $val }
            default return element { $key } { $instance-property }
    }
};


(: instance-to-envelope 
 : This function is used to wrap sources and entity instances
 : within the same document
 : TODO EA-3, this will be part of XQuery server library, not generated code.
 :)
declare function race:instance-to-envelope(
    $entity-instance as map:map
) as document-node()
{
    document {
        element es:envelope {
            element es:instance {
                element es:info {
                    element es:title { "Race" },
                    element es:version { "0.0.1" }
                },
                race:instance-to-canonical-xml($entity-instance)
            },
            element es:attachments {
                map:get($entity-instance, "$attachments") 
            }
        }
    }
};


(: instance-from-document 
 : if you have modified instance-to-envelope
 : you may need also to modify this function
 :)
declare function race:instance-from-document(
    $document as document-node()
) as map:map*
{
    let $xml-from-document := race:instance-xml-from-document($document)
    for $root-instance in $xml-from-document
        let $instance := json:object()
        let $_ :=
            for $property in $root-instance/*
            return
                if ($property/element())
                then map:put($instance, local-name($property), $property/* ! race:child-instance(.))
                else map:put($instance, local-name($property), data($property))
        return $instance
};

declare function race:child-instance(
    $element as element()
) as map:map*
{
    let $child := json:object()
    let $_ := 
        for $property in $element/*
        return
            if ($property/element())
            then map:put($child, local-name($property), race:child-instance($property))
            else map:put($child, local-name($property), data($property))
    return $child
};


(:~
 : Returns all XML from within a document envelope except the es:info.
 : This function is generic enough not to require customization for
 : most entity type implementations.
 :)
declare function race:instance-xml-from-document(
    $document as document-node()
) as element()
{
    $document//es:instance/(* except es:info)
};

declare function race:instance-json-from-document(
    $document as document-node()
) as object-node()
{
    let $instance := race:instance-from-document($document)
    return xdmp:to-json($instance)/node()
};


declare function race:instance-get-attachments(
    $document as document-node()
) as element()*
{
    $document//es:attachments/*
};

