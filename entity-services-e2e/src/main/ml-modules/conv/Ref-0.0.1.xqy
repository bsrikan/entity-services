xquery version "1.0-ml";

(: This module was generated by MarkLogic Entity Services. 
 : The source entity type document was Ref-0.0.1
 :
 : Modification History:
 :   Generated at timestamp: 2016-04-14T14:13:03.231413-07:00
 :   Persisted by AUTHOR
 :   Date: DATE
 :)
module namespace ref = "http://refCombo#Ref-0.0.1";

import module namespace es = "http://marklogic.com/entity-services" 
    at "/MarkLogic/entity-services/entity-services.xqy";


declare private function ref:include-if-exists(
    $property-path,
    $instance,
    $property-key,
    $value
) as empty-sequence()
{
    if (exists($property-path))
    then 
    map:put($instance, $property-key, $value) 
    else ()
};


(: extract-instance-{entity-type} Functions :)

(:~
    TODO make descriptive comment for extract-instance-Customer
 :)
declare function ref:extract-instance-Customer(
    $source-node as node()
) as map:map
{
    let $instance := json:object()
    let $_ := map:put($instance, "$type", "Customer")
    let $_ := map:put($instance, "$attachments", $source-node)
    let $_ := ref:include-if-exists($source-node/Customer/CustomerId, $instance, 'CustomerId', data($source-node/Customer/CustomerId))
    let $_ := ref:include-if-exists($source-node/Customer/CompanyName, $instance, 'CompanyName', data($source-node/Customer/CompanyName))
    let $_ := ref:include-if-exists($source-node/Customer/Country, $instance, 'Country', data($source-node/Customer/Country))
    let $_ := ref:include-if-exists($source-node/Customer/Address, $instance, 'Address', data($source-node/Customer/Address))
   
    return $instance
};
    
(:~
    TODO make descriptive comment for extract-instance-Product
 :)
declare function ref:extract-instance-Product(
    $source-node as node()
) as map:map
{
    let $instance := json:object()
    let $_ := map:put($instance, "$type", "Product")
    let $_ := map:put($instance, "$attachments", $source-node)
    let $_ := ref:include-if-exists($source-node/Product/ProductName, $instance, 'ProductName', data($source-node/Product/ProductName))
    let $_ := ref:include-if-exists($source-node/Product/ProductID, $instance, 'ProductID', data($source-node/Product/ProductID))
    let $_ := ref:include-if-exists($source-node/Product/UnitPrice, $instance, 'UnitPrice', data($source-node/Product/UnitPrice))
    let $_ := ref:include-if-exists($source-node/Product/SupplierID, $instance, 'SupplierID', data($source-node/Product/SupplierID))
    let $_ := ref:include-if-exists($source-node/Product/Discontinued, $instance, 'Discontinued', data($source-node/Product/Discontinued))
   
    return $instance
};
    
(:~
    TODO make descriptive comment for extract-instance-Order
 :)
declare function ref:extract-instance-Order(
    $source-node as node()
) as map:map
{
    let $instance := json:object()
    let $_ := map:put($instance, "$type", "Order")
    let $_ := map:put($instance, "$attachments", $source-node)
    let $_ := ref:include-if-exists($source-node/Order/OrderID, $instance, 'OrderID', data($source-node/Order/OrderID))
    let $_ := ref:include-if-exists($source-node/Order/CustomerID, $instance, 'CustomerID', 
    if ($source-node/Order/CustomerID/element())
    then json:to-array($source-node/Order/CustomerID ! ref:extract-instance-Customer(.))
    else data($source-node/Order/CustomerID))
    let $_ := ref:include-if-exists($source-node/Order/OrderDate, $instance, 'OrderDate', data($source-node/Order/OrderDate))
    let $_ := ref:include-if-exists($source-node/Order/ShipAddress, $instance, 'ShipAddress', data($source-node/Order/ShipAddress))
    let $_ := ref:include-if-exists($source-node/Order/OrderDetails, $instance, 'OrderDetails', 
    if ($source-node/Order/OrderDetails/element())
    then json:to-array($source-node/Order/OrderDetails ! ref:extract-instance-OrderDetail(.))
    else data($source-node/Order/OrderDetails))
   
    return $instance
};
    
(:~
    TODO make descriptive comment for extract-instance-OrderDetail
 :)
declare function ref:extract-instance-OrderDetail(
    $source-node as node()
) as map:map
{
    let $instance := json:object()
    let $_ := map:put($instance, "$type", "OrderDetail")
    let $_ := map:put($instance, "$attachments", $source-node)
    let $_ := ref:include-if-exists($source-node/OrderDetail/ProductID, $instance, 'ProductID', 
    if ($source-node/OrderDetail/ProductID/element())
    then json:to-array($source-node/OrderDetail/ProductID ! ref:extract-instance-Product(.))
    else data($source-node/OrderDetail/ProductID))
    let $_ := ref:include-if-exists($source-node/OrderDetail/UnitPrice, $instance, 'UnitPrice', data($source-node/OrderDetail/UnitPrice))
    let $_ := ref:include-if-exists($source-node/OrderDetail/Quantity, $instance, 'Quantity', data($source-node/OrderDetail/Quantity))
   
    return $instance
};
    

(: instance-to-canonical-xml function
 : Depending on the relationships among your entity types
 : you may wish to modify sections of this function
 : to meet your own purposes.
 :)
declare function ref:instance-to-canonical-xml(
    $entity-instance as map:map
) as element()
{
    (: Construct an element that is named the same as the Entity Type :)
    element { map:get($entity-instance, "$type") }  {
        for $key in map:keys($entity-instance)
        let $instance-property := map:get($entity-instance, $key)
        where ($key castable as xs:NCName and $key ne "$type")
        return
            typeswitch ($instance-property)
            (: This branch handles embedded objects.  You can choose to prune
               an entity's representation of extend it with lookups here. :)
            case json:object+ 
                return
                    for $prop in $instance-property
                    return element { $key } { ref:instance-to-canonical-xml($prop) }
            (: An array can also treated as multiple elements :)
            case json:array
                return 
                    for $val in json:array-values($instance-property)
                    return
                        if ($val instance of json:object)
                        then element { $key } { ref:instance-to-canonical-xml($val) }
                        else element { $key } { $val }
            (: A sequence of values should be simply treated as multiple elements :)
            case item()+
                return 
                    for $val in $instance-property
                    return element { $key } { $val }
            default return element { $key } { $instance-property }
    }
};


(: instance-to-envelope 
 : This function is used to wrap sources and entity instances
 : within the same document
 : TODO EA-3, this will be part of XQuery server library, not generated code.
 :)
declare function ref:instance-to-envelope(
    $entity-instance as map:map
) as document-node()
{
    document {
        element es:envelope {
            element es:instance {
                element es:info {
                    element es:title { "Ref" },
                    element es:version { "0.0.1" }
                },
                ref:instance-to-canonical-xml($entity-instance)
            },
            element es:attachments {
                map:get($entity-instance, "$attachments") 
            }
        }
    }
};


(: instance-from-document 
 : if you have modified instance-to-envelope
 : you may need also to modify this function
 :)
declare function ref:instance-from-document(
    $document as document-node()
) as map:map*
{
    let $xml-from-document := ref:instance-xml-from-document($document)
    for $root-instance in $xml-from-document
        let $instance := json:object()
        let $_ :=
            for $property in $root-instance/*
            return
                if ($property/element())
                then map:put($instance, local-name($property), $property/* ! ref:child-instance(.))
                else map:put($instance, local-name($property), data($property))
        return $instance
};

declare function ref:child-instance(
    $element as element()
) as map:map*
{
    let $child := json:object()
    let $_ := 
        for $property in $element/*
        return
            if ($property/element())
            then map:put($child, local-name($property), ref:child-instance($property))
            else map:put($child, local-name($property), data($property))
    return $child
};


(:~
 : Returns all XML from within a document envelope except the es:info.
 : This function is generic enough not to require customization for
 : most entity type implementations.
 :)
declare function ref:instance-xml-from-document(
    $document as document-node()
) as element()
{
    $document//es:instance/(* except es:info)
};

declare function ref:instance-json-from-document(
    $document as document-node()
) as object-node()
{
    let $instance := ref:instance-from-document($document)
    return xdmp:to-json($instance)/node()
};


declare function ref:instance-get-attachments(
    $document as document-node()
) as element()*
{
    $document//es:attachments/*
};